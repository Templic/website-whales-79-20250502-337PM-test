/**
 * TypeScript Error Management API Routes
 * 
 * This module provides enhanced routes for managing TypeScript errors using
 * the TypeScriptErrorAdapter which connects to the database.
 */

import express from 'express';
import { Request, Response } from 'express';
import { logSecurityEvent } from '../../security';
import path from 'path';
import fs from 'fs';
import util from 'util';
import { exec } from 'child_process';
import { createRequire } from 'module';

// Use createRequire to load CommonJS modules in ES modules
const require = createRequire(import.meta.url);
const typescriptErrorAdapter = require('../../utils/typescript-error-adapter');

const execPromise = util.promisify(exec);
const router = express.Router();

// Helper to run a TypeScript scan with the advanced ts-error-finder.ts
async function runTypeScriptScan(aiEnabled: boolean = false) {
  try {
    // Create a scan record in the database
    const scan = await typescriptErrorAdapter.createScan({ aiEnabled });
    
    // Return the scan ID immediately so the client can poll for updates
    return {
      success: true,
      scanId: scan.id,
      message: 'Scan initiated successfully'
    };
  } catch (error) {
    console.error('Failed to initiate TypeScript scan:', error);
    return {
      success: false,
      message: 'Failed to initiate TypeScript scan',
      error: String(error)
    };
  }
}

// Run the scan in the background
async function runScanInBackground(scanId: string, aiEnabled: boolean) {
  try {
    console.log(`Starting TypeScript scan ${scanId} with AI enabled: ${aiEnabled}`);
    
    // Detect TypeScript files and errors
    let errorCount = 0;
    
    // This is a placeholder for running the actual scan
    // In a real implementation, this would run ts-error-finder.ts
    const projectRoot = path.resolve('.');
    const command = `node -r ts-node/register advanced-ts-error-finder.ts --project ${projectRoot} ${aiEnabled ? '--ai' : ''}`;
    
    // Run the command
    const { stdout, stderr } = await execPromise(command);
    
    if (stderr) {
      console.error(`Error running TypeScript scan: ${stderr}`);
      throw new Error(stderr);
    }
    
    // Parse the scan results
    const scanResults = JSON.parse(stdout);
    errorCount = scanResults.totalErrors || 0;
    
    // Record each error in the database
    if (scanResults.errors && Array.isArray(scanResults.errors)) {
      for (const error of scanResults.errors) {
        await typescriptErrorAdapter.addError(scanId, {
          code: error.code,
          file: error.file,
          line: error.line,
          column: error.column,
          message: error.message,
          context: error.context,
          category: error.category,
          severity: error.severity
        });
      }
    }
    
    // Update scan record with results
    await typescriptErrorAdapter.updateScan(scanId, {
      status: 'COMPLETED',
      errorCount,
      endTime: new Date(),
      summary: scanResults.summary || 'Scan completed'
    });
    
    // Log success
    logSecurityEvent('Typescript scan completed', 'info', { scanId, errorCount: String(errorCount) });
    
  } catch (error) {
    console.error(`Error in TypeScript scan ${scanId}:`, error);
    
    // Update scan record with error
    await typescriptErrorAdapter.updateScan(scanId, {
      status: 'FAILED',
      endTime: new Date(),
      summary: `Scan failed: ${error}`
    });
    
    // Log error
    logSecurityEvent('Typescript scan failed', 'error', { scanId, errorMessage: String(error) });
  }
}

// Generate AI fix for an error
async function generateAIFixInBackground(scanId: string, errorId: number, error: any) {
  try {
    console.log(`Generating AI fix for error ${errorId} in scan ${scanId}`);
    
    // In a real implementation, this would call OpenAI API
    // For now, we'll create a placeholder fix
    await typescriptErrorAdapter.addFix(errorId, {
      fixedCode: `// Fixed code would be here\n// Original error: ${error.message}`,
      explanation: 'This is a placeholder fix generated by the system. In a production implementation, OpenAI would analyze the error and suggest a proper fix.',
      confidence: 70,
      aiGenerated: true
    });
    
    // Log success
    logSecurityEvent('AI fix generated', 'info', { scanId, errorId: String(errorId), file: String(error.file), line: String(error.line) });
    
  } catch (error) {
    console.error(`Error generating AI fix:`, error);
    
    // Log error
    logSecurityEvent('AI fix generation failed', 'error', { scanId, errorId: String(errorId), errorMessage: String(error) });
  }
}

// Apply a fix to a file
async function applyFixToFile(filePath: string, lineNumber: number, fixedCode: string): Promise<boolean> {
  try {
    // Read the file
    const fileContent = fs.readFileSync(filePath, 'utf8');
    const lines = fileContent.split('\n');
    
    // Ensure line number is valid (1-based in errors, 0-based in array)
    if (lineNumber < 1 || lineNumber > lines.length) {
      throw new Error(`Invalid line number: ${lineNumber}`);
    }
    
    // Replace the line
    lines[lineNumber - 1] = fixedCode;
    
    // Write the file back
    fs.writeFileSync(filePath, lines.join('\n'));
    
    return true;
  } catch (error) {
    console.error(`Error applying fix to ${filePath}:${lineNumber}:`, error);
    return false;
  }
}

// API Routes

// Start a new TypeScript scan
router.post('/scan', async (req: Request, res: Response) => {
  try {
    const aiEnabled = req.body.aiEnabled === true; // Ensure boolean
    
    // Start the scan
    const result = await runTypeScriptScan(aiEnabled);
    
    if (result.success) {
      // Run the scan in the background
      runScanInBackground(result.scanId, aiEnabled);
    }
    
    // Return immediately with scan ID
    res.json(result);
  } catch (error) {
    console.error('Error starting TypeScript scan:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

// Get scan status
router.get('/scan/:scanId', async (req: Request, res: Response) => {
  try {
    const scanId = req.params.scanId;
    
    // Get scan from database
    const scan = await typescriptErrorAdapter.getScan(scanId);
    
    if (!scan) {
      return res.status(404).json({
        success: false,
        message: `Scan ${scanId} not found`
      });
    }
    
    res.json({
      success: true,
      scan
    });
  } catch (error) {
    console.error(`Error getting scan ${req.params.scanId}:`, error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

// Get all scans
router.get('/scans', async (req: Request, res: Response) => {
  try {
    // Get all scans from database
    const scans = await typescriptErrorAdapter.getAllScans();
    
    res.json({
      success: true,
      scans
    });
  } catch (error) {
    console.error('Error getting all scans:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

// Get errors for scan
router.get('/scan/:scanId/errors', async (req: Request, res: Response) => {
  try {
    const scanId = req.params.scanId;
    
    // Ensure scan exists
    const scan = await typescriptErrorAdapter.getScan(scanId);
    
    if (!scan) {
      return res.status(404).json({
        success: false,
        message: `Scan ${scanId} not found`
      });
    }
    
    // Get errors for scan
    const errors = await typescriptErrorAdapter.getErrorsForScan(scanId);
    
    res.json({
      success: true,
      errors
    });
  } catch (error) {
    console.error(`Error getting errors for scan ${req.params.scanId}:`, error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

// Generate AI fix for error
router.post('/error/:errorId/ai-fix', async (req: Request, res: Response) => {
  try {
    const errorId = parseInt(req.params.errorId);
    
    // Get scan ID for this error (assuming you have a way to lookup this relationship)
    // For now, we'll use a placeholder
    const scanId = req.body.scanId;
    
    if (!scanId) {
      return res.status(400).json({
        success: false,
        message: 'Scan ID is required'
      });
    }
    
    // Get error details
    const errors = await typescriptErrorAdapter.getErrorsForScan(scanId);
    const error = errors.find(e => e.id === errorId);
    
    if (!error) {
      return res.status(404).json({
        success: false,
        message: `Error ${errorId} not found`
      });
    }
    
    // Generate AI fix in background
    generateAIFixInBackground(scanId, errorId, error);
    
    res.json({
      success: true,
      message: 'AI fix generation started',
      errorId
    });
  } catch (error) {
    console.error(`Error starting AI fix for error ${req.params.errorId}:`, error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

// Get fixes for error
router.get('/error/:errorId/fixes', async (req: Request, res: Response) => {
  try {
    const errorId = parseInt(req.params.errorId);
    
    // Get fixes for error
    const fixes = await typescriptErrorAdapter.getFixesForError(errorId);
    
    res.json({
      success: true,
      fixes
    });
  } catch (error) {
    console.error(`Error getting fixes for error ${req.params.errorId}:`, error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

// Apply fix to file
router.post('/fix/:fixId/apply', async (req: Request, res: Response) => {
  try {
    const fixId = parseInt(req.params.fixId);
    const { errorId, filePath, lineNumber, fixedCode } = req.body;
    
    if (!errorId || !filePath || !lineNumber || !fixedCode) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }
    
    // Apply fix to file
    const applied = await applyFixToFile(filePath, lineNumber, fixedCode);
    
    if (!applied) {
      return res.status(500).json({
        success: false,
        message: 'Failed to apply fix'
      });
    }
    
    // Update error status in database (assuming you have a way to do this)
    // For now, we'll just return success
    
    res.json({
      success: true,
      message: 'Fix applied successfully',
      fixId,
      errorId,
      filePath,
      lineNumber
    });
  } catch (error) {
    console.error(`Error applying fix ${req.params.fixId}:`, error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: String(error)
    });
  }
});

export default router;