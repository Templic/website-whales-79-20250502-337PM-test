#!/usr/bin/env node

/**
 * Quick Malware Scan
 * 
 * This script performs a focused malware scan of dependencies and code.
 */

import fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

// Constants
const SCAN_RESULTS_DIR = path.join(process.cwd(), 'logs', 'security-scans');

// Ensure directories exist
if (!fs.existsSync(SCAN_RESULTS_DIR)) {
  fs.mkdirSync(SCAN_RESULTS_DIR, { recursive: true });
}

// Logger
function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [${type.toUpperCase()}] ${message}`);
}

// Vulnerability type
/**
 * @typedef {Object} SecurityVulnerability
 * @property {string} id - Unique identifier for the vulnerability
 * @property {'critical'|'high'|'medium'|'low'} severity - Severity level
 * @property {string} description - Description of the vulnerability
 * @property {string} [recommendation] - Recommendation for fixing the vulnerability
 */

/**
 * Main scan function
 */
async function runMalwareScan() {
  const startTime = Date.now();
  log(`Starting quick malware scan...`);
  
  /** @type {SecurityVulnerability[]} */
  const vulnerabilities = [];
  
  try {
    // Scan imports for malware
    await scanImportsForMalware(vulnerabilities);
    
    // Process scan results
    const scanDuration = Date.now() - startTime;
    
    // Count issues by severity
    let criticalIssues = 0;
    let highIssues = 0;
    let mediumIssues = 0;
    let lowIssues = 0;
    
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'critical': criticalIssues++; break;
        case 'high': highIssues++; break;
        case 'medium': mediumIssues++; break;
        case 'low': lowIssues++; break;
      }
    });
    
    // Build scan results object
    const scanResults = {
      timestamp: new Date().toISOString(),
      scanDuration,
      scanType: 'malware-quick',
      totalIssues: vulnerabilities.length,
      criticalIssues,
      highIssues,
      mediumIssues,
      lowIssues,
      vulnerabilities
    };
    
    // Save scan results
    const scanTimestamp = new Date().toISOString().replace(/:/g, '-');
    const scanResultFile = path.join(SCAN_RESULTS_DIR, `malware-scan-${scanTimestamp}.json`);
    fs.writeFileSync(scanResultFile, JSON.stringify(scanResults, null, 2));
    
    // Display summary
    log(`Malware scan completed in ${scanDuration}ms`);
    log(`Results: ${scanResults.totalIssues} issues found (${criticalIssues} critical, ${highIssues} high, ${mediumIssues} medium, ${lowIssues} low)`);
    
    // Show vulnerabilities in terminal
    if (vulnerabilities.length > 0) {
      log('Potential malware or security issues:', 'warning');
      vulnerabilities.forEach((v, i) => {
        log(`${i + 1}. [${v.severity.toUpperCase()}] ${v.description}`, v.severity);
        if (v.recommendation) {
          log(`   Recommendation: ${v.recommendation}`, 'info');
        }
      });
    } else {
      log('No malware detected in current dependencies', 'success');
    }
    
  } catch (error) {
    log(`Error during malware scan: ${error}`, 'error');
    if (error.stack) {
      log(error.stack, 'error');
    }
  }
}

/**
 * Enhanced scan of imported modules for known vulnerabilities, exploits, malware
 * @param {SecurityVulnerability[]} vulnerabilities - Array to add vulnerabilities to
 */
async function scanImportsForMalware(vulnerabilities) {
  log('Scanning imports for known vulnerabilities, exploits, and malware...');
  
  // Get package.json to scan installed dependencies
  try {
    // Read package.json to get actual dependencies
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    const packageJsonData = fs.readFileSync(packageJsonPath, 'utf8');
    const packageJson = JSON.parse(packageJsonData);
    
    // Extract all dependencies
    const allDependencies = {
      ...(packageJson.dependencies || {}),
      ...(packageJson.devDependencies || {})
    };
    
    const packageNames = Object.keys(allDependencies);
    log(`Scanning ${packageNames.length} installed packages...`);
    
    // Known malicious packages (expanded list)
    const knownMaliciousImports = [
      'malicious-package-1',
      'malicious-package-2',
      'event-logger', // Known typosquatting package
      'cross-env-shell', // Fake version of legitimate package
      'eslint-config-airbnb-standard', // Known trojan package
      'electron-native-notify', // Known for crypto mining
      'codecov', // Historical vulnerability (for demonstration)
      'browserslist', // Historical vulnerability (for demonstration)
      'ua-parser-js', // Historical vulnerability
      'coa', // Historical vulnerability
      'rc', // Historical vulnerability
      'node-ipc', // Politically motivated malware
      'event-source-polyfill', // Suspicious package
      'nodetest', // Typosquatting
      'javascripttest', // Typosquatting
      'simple-dropbox', // Data stealing
      'n0de-env', // Typosquatting for node-env
      'loadyaml', // Malicious
      'fallguys', // Unauthorized package
      'nodejs-encrypt', // Unauthorized package
      'discord-lofy', // Malicious
      'discord-youtube-dl', // Malicious
      'create-test-repo', // Malicious
      'discord-selfbot-rpc', // Malicious
      'node-dataplicity', // Malicious
      'discord-dose', // Malicious
      'express-toobusy', // Supply chain
      'npm-backdoor', // Explicit backdoor
      'mining-tarball', // Crypto mining
      'crypto-miner', // Crypto mining
      'discordrpc', // Data stealing
      'wallet-address-validator', // Potential crypto theft
      'http-scanner', // Network scanning
      'chromium-browser' // Malicious execution
    ];
    
    // Check for common patterns of malicious code injection in package json
    const packageJsonString = JSON.stringify(packageJson);
    const maliciousPatterns = [
      'curl|wget.*\\|\\s*bash', // Bash piping
      'eval\\(.*base64', // Base64 eval
      '\\${.*:\\/\\/}', // Command injection
      'process\\.env.*\\|\\|.*require', // Env variable leakage
      'require\\(.*child_process', // Child process exec
      'preinstall.*curl', // Suspicious preinstall
      'install.*curl', // Suspicious install
      'postinstall.*curl', // Suspicious postinstall
      '\\.replace\\(\\/[^,]+\\/g,[^,]+\\)', // String obfuscation
      'new\\s+Function\\(.*\\)', // Dynamic function creation
      'globalThis\\.process', // Another way to access process
      'global\\.process' // Another way to access process
    ];
    
    // Check for malicious patterns in package.json
    for (const pattern of maliciousPatterns) {
      const regex = new RegExp(pattern, 'i');
      if (regex.test(packageJsonString)) {
        vulnerabilities.push({
          id: uuidv4(),
          severity: 'critical',
          description: `Potentially malicious code pattern detected in package.json: ${pattern}`,
          recommendation: 'Review package.json for malicious scripts immediately'
        });
      }
    }
    
    // Check for typosquatting or dependency confusion
    const popularPackages = {
      'lodash': 'loadash',
      'express': 'expres',
      'react': 'reactjs',
      'axios': 'axois',
      'moment': 'momentjs',
      'jquery': 'jqury',
      'chalk': 'chalks',
      'dotenv': 'dot-env',
      'request': 'requests'
    };
    
    // Check for exact matches of known malicious packages
    for (const packageName of packageNames) {
      if (knownMaliciousImports.includes(packageName)) {
        vulnerabilities.push({
          id: uuidv4(),
          severity: 'critical',
          description: `Known malicious package detected: ${packageName}`,
          recommendation: 'Remove this package immediately and check for any unusual system activity'
        });
      }
      
      // Check for suspicious names similar to popular packages (typosquatting)
      for (const [legitimate, typosquat] of Object.entries(popularPackages)) {
        if (packageName === typosquat) {
          vulnerabilities.push({
            id: uuidv4(),
            severity: 'high',
            description: `Possible typosquatting package detected: ${packageName} (similar to ${legitimate})`,
            recommendation: `Verify the package is legitimate and consider replacing with ${legitimate}`
          });
        }
      }
    }
    
    // Add scan result
    log(`Package scan completed. ${vulnerabilities.length} potential issues found.`);
    
  } catch (error) {
    log(`Error scanning for malicious imports: ${error}`, 'error');
    vulnerabilities.push({
      id: uuidv4(),
      severity: 'medium',
      description: 'Error scanning for malicious imports',
      recommendation: 'Manually review dependencies for suspicious packages'
    });
  }
}

// Run the scan
runMalwareScan();